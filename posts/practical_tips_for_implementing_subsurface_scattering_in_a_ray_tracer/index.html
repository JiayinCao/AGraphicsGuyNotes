<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">

    <meta name="author" content="Jiayin Cao">
    <meta name="description" content="This blog is about the iterations I made during implementing subsurface scattering in my renderer.">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://agraphicsguynotes.com/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/sss_dragon.png"/>

<meta name="twitter:title" content="Practical Tips for Implementing Subsurface Scattering in a Ray Tracer"/>
<meta name="twitter:description" content="This blog is about the iterations I made during implementing subsurface scattering in my renderer."/>

    <meta property="og:title" content="Practical Tips for Implementing Subsurface Scattering in a Ray Tracer" />
<meta property="og:description" content="This blog is about the iterations I made during implementing subsurface scattering in my renderer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://agraphicsguynotes.com/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/" /><meta property="og:image" content="https://agraphicsguynotes.com/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/sss_dragon.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-13T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-11-13T00:00:00+00:00" />


    <title>
  Practical Tips for Implementing Subsurface Scattering in a Ray Tracer Â· A Graphics Guy&#39;s Note
</title>

    
      <link rel="canonical" href="https://agraphicsguynotes.com/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css" integrity="sha256-gsmEoJAws/Kd3CjuOQzLie5Q3yshhvmo7YNtBG7aaEY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.9836c03fe5c87d102278a33e86d0591ef36c89b1e17e8e547ebf84c05cee010e.css" integrity="sha256-mDbAP&#43;XIfRAieKM&#43;htBZHvNsibHhfo5Ufr&#43;EwFzuAQ4=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.717236c74e0a5208ef73964a9f44c6b443b689a95b270d8b2a40d0c012460dac.css" integrity="sha256-cXI2x04KUgjvc5ZKn0TGtEO2ialbJw2LKkDQwBJGDaw=" crossorigin="anonymous" media="screen" />
      
    

    
      <link rel="stylesheet" href="/css/custom.css" />
    

    
      
      
        
        <link rel="stylesheet" href="/main.min.c6871eec105836f05025bd3d682a4f431abfdb83d740febdda8f8be50661a7de.css" integrity="sha256-xoce7BBYNvBQJb09aCpPQxq/24PXQP692o&#43;L5QZhp94=" crossorigin="anonymous" media="screen" />
      
    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    

    
    
      
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-7T6R55SCY1"></script>
      <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-7T6R55SCY1');
      </script>
    

    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false}
      ]
    });
  });
</script>

<style>
  .katex-display > .katex {
    text-align: left !important;
  }
</style>
    

    <meta name="generator" content="Hugo 0.117.0">

    <link rel="stylesheet" href="/css/print.css" media="print">
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=""
  >
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      A Graphics Guy&#39;s Note
    </a>
    
      
        <span id="dark-mode-toggle" class="float-right">
          <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
        </span>
      
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
        
        
        
          <li class="navigation-item separator">
            <span>|</span>
          </li>
        
      </ul>
    
  </section>
</nav>

      <script>
        
        document.getElementById('dark-mode-toggle').addEventListener('click', () => {
          const isdarkmode = !document.body.classList.contains("colorscheme-dark");
          localStorage.setItem("pref-theme", isdarkmode ? 'dark_dimmed' : 'light');
        });
      </script>

      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Practical Tips for Implementing Subsurface Scattering in a Ray Tracer</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2020-11-13T00:00:00Z'>
                November 13, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              36-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>
      
      <div>
        
        <p>Subsurface scattering has always been a challenge in computer graphics. Even in offline rendering, some of the common practical solutions are nowhere near unbiased. In certain algorithms, there are some pretty aggressive assumptions made to make things under control.
However, despite the complexity in subsurface scattering algorithms, it is by no means a feature that can be missing from a practical rendering engine. Major commercial renderers, like <a href="https://www.arnoldrenderer.com/">Arnold</a>, <a href="https://www.maxon.net/en-us/products/cinema-4d/overview/">Cinema 4D</a>, etc, all have very sophisticated and solid implementation of SSS. Robust implementation of SSS also exists in open-source projects, like <a href="https://www.cycles-renderer.org/">Cycles</a> and <a href="https://luxcorerender.org/">luxcorerenderer</a>, and even some research-based projects maintained by only a handful of people, like <a href="https://pbrt.org/">PBRT</a> and <a href="https://www.mitsuba-renderer.org/">mitsuba</a>. What is even amazing is that real-time rendering also has practical and efficient subsurface scattering implementation. In game industry, there is no shortage of amazing games with stunning and convincing skin rendering, for example, like <a href="https://www.playstation.com/en-us/games/the-last-of-us-part-ii-ps4/">the Last of Us Part II</a>.</p>
<p>I happened to have some time last year and eventually finished an implementation that I&rsquo;m satisfied with after quite a few iterations. Following is a shot using <a href="https://sort-renderer.com">my renderer</a> and it is a good example demonstrating the SSS feature in it.
Also, all other images in this blog are rendered using my renderer too.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/blender_splash.png"/>
</figure>

<p>There are quite some resources about SSS theories on the internet.
However, I rarely see any material revealing the specific details to be noted in implementing SSS algorithm.
This could totally be because I haven&rsquo;t done enough research work in this field. But it is still worth my time to put down all the notes I have during my iterations.
Starting from integrating PBRT 3rd edition&rsquo;s implementation, I quickly noticed that the implementation works for some cases, but there are cases where it fails to converge efficiently. By comparing with Cycles implementation, I made some progress with more iterations.</p>
<p>This blog is about the iterations that I have made on top of PBRT&rsquo;s implementation.
I will briefly mention the basics of SSS theory in PBRT. My introduction covers only part of what PBRT talks about in subsurface scattering.
It is highly suggested to read PBRT&rsquo;s SSS chapter first before moving forward with reading this blog.
Most of this blog will be talking about the iterations that I made to make it more robust.</p>
<h1 id="what-is-subsurface-scattering">What is Subsurface Scattering</h1>
<p>Below is a comparison of a dragon with and without subsurface scattering.</p>







 
 
 
 




<style>
.ba-slider1d9792c1cdd84287b704ca1876c4de13 {
    position: relative;
    overflow: hidden;
    width: 100%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-slider1d9792c1cdd84287b704ca1876c4de13 img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-slider1d9792c1cdd84287b704ca1876c4de13 .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-slider1d9792c1cdd84287b704ca1876c4de13 .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-slider1d9792c1cdd84287b704ca1876c4de13 .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-container1d9792c1cdd84287b704ca1876c4de13 {
    position: relative;
    text-align: center;
}

.ba-bottom-left1d9792c1cdd84287b704ca1876c4de13,
.ba-bottom-right1d9792c1cdd84287b704ca1876c4de13 {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-left1d9792c1cdd84287b704ca1876c4de13 {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-right1d9792c1cdd84287b704ca1876c4de13 {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-slider1d9792c1cdd84287b704ca1876c4de13" id="ba-slider-1d9792c1cdd84287b704ca1876c4de13">
        <div class="ba-container1d9792c1cdd84287b704ca1876c4de13">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/regular_dragon.png">
            <div class="ba-bottom-right1d9792c1cdd84287b704ca1876c4de13"></div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/sss_dragon.png">
            <div class="ba-bottom-left1d9792c1cdd84287b704ca1876c4de13"></div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-left1d9792c1cdd84287b704ca1876c4de13');
    var rightLink = container.find('.ba-link-right1d9792c1cdd84287b704ca1876c4de13');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-1d9792c1cdd84287b704ca1876c4de13').beforeAfter();
</script>

<p>As we can easily see from the comparison, subsurface scattering shows a more waxy feeling, it feels more transparent than the Lambert BRDF.
In a nutshell, subsurface scattering means the incoming light penetrates through the surface of an object and leaves from another position that may not be the same as the position where it enters the surface. The most common example in our everyday life is human skin.
So the question is, what makes it a difficult challenge in computer graphics? If we get back to the rendering equation,</p>

$$ {L_{o}(p_{o},\omega_{o}) = L_{e}(p_o, \omega_{o}) &#43; \int_{\Omega} L_{i}(p_o, \omega_{i}) *f(p_o, \omega_{i}, \omega_{o} ) *cos(\theta_{i}) d\omega_{i}} $$
<p>It is not hard to notice that there is no support for subsurface scattering in this equation at all since the whole integral is just about one single position. When we talk about BRDF, it is a simplified version of BSSRDF. We can treat BRDF as a delta function version of BSSRDF. If we look at the rendering equation in a more generalized way, it can be written like this,</p>

$$ {L_{o}(p_{o},\omega_{o}) = L_{e}(p_o, \omega_{o}) &#43; \int_A \int_{\Omega} L_{i}(p_o, \omega_{i}) *f(p_o, p_i, \omega_{i}, \omega_{o} ) *cos(\theta_{i}) d\omega_{i} dA } $$
<p>As we can see, we gained two more dimensions by considering subsurface scattering. In other words, instead of just considering light coming from all directions at a single point on the surface, we also need to evaluate the contribution of light coming from all other positions. The direction domain is an isolated domain that is generally not affected by other factors. However, the same thing doesn&rsquo;t go true for positions, which highly depends on the shape of the geometry, meaning accurate importance sampling position is a lot harder than sampling directions like what we used to do in BRDF evaluation.</p>
<p>And even if we have a good importance sampling algorithm, integrating the implementation with the existed path tracing algorithm that used to only consider BRDF also requires close attention to avoid mistakes that could accidentally introduce bias. A practical render engine also supports multiple layers of BSSRDFs, like Cycles. I also implemented the algorithm to support multiple layers of BSSRDF so that there is more flexibility of asset authoring.</p>
<h1 id="basic-idea-of-sss">Basic Idea of SSS</h1>
<p>It makes very little sense to put down all of the math details of subsurface scattering here since there are already lots of resources available online.
However, to avoid confusing readers, it is still worthwhile to introduce the basic concept briefly.
Since I started by integrating PBRT&rsquo;s implementation, the basic theory mentioned below is just a brief introduction to the implementation of SSS in PBRT 3rd edition.
For a deeper understanding of the way it works, PBRT has a few chapters that have a pretty solid explanation of every single detail in it.</p>
<p>Whenever we have a new BRDF model, the two most important things we need to do are always to figure out a proper way to evaluate the BRDF and a solid importance sampling algorithm so that the implementation could converge efficiently. BSSRDF implementation sounded a bit intimidated to me at the beginning when I literally knew nothing about it. But the reality is that this is not that different from adding a new BRDF model, we still need to figure out a proper way to evaluate the function and an efficient importance sampling algorithm, for both direction and position. The only extra thing that is needed is to adjust the path tracing algorithm to make it aware of SSS and evaluate it when necessary.</p>
<h2 id="evaluating-bssrdf">Evaluating BSSRDF</h2>
<p>This <a href="https://graphics.stanford.edu/papers/bssrdf/bssrdf.pdf">paper</a> first introduced the model of separable BSSRDF to make things manageable.
It achieved so by decoupling factors from each other.
PBRT&rsquo;s work is based on top of it.</p>

$$ S(p_o, p_i, \omega_o, \omega_i) \approx ( 1 - F_r(cos\theta_o) ) \space S_p(p_o, p_i) \space S_w(w_i)$$
<p>With three parts in this model, the first part is responsible for accounting for the energy loss during light leaving the surface from inside.
 $ S_p(p_o, p_i) $ 
  is mainly responsible for approximating the falloff factor due to the distance between  $ p_o $ 
 and  $ p_i $ 
 .
Like the first part, the last one is for evaluating light energy loss due to light coming in through the surface.</p>
<p>The complexity of the simplified function is already a lot simpler with the approximation.
To simplify things even more,  $ S_p(p_o, p_i) $ 
  will only consider the distance of the two input points instead of the relative positions with each other on the surface of the object.
This greatly reduces the complexity of the problem again since BSSRDF will need no knowledge of the specific shape of the object, where the two points are lying on, to be evaluated.
And this is what we usually call &lsquo;diffusion profile&rsquo;.
A way to visualize it is to shoot a lazer thin ray on a totally flat surface with subsurface scattering.
One nice thing about this simplification is that the model is independent of the specific model of diffusion profile, which means that we can choose whatever we want as long as it is normalized.
Mathematically, the equation below needs to hold true,</p>

$$ \int_0^{2\pi} \int_0^{\infty} S_p(r) \space r \space dr \space d\theta = 1$$
<h2 id="importance-sampling">Importance Sampling</h2>
<p>Importance sampling of BSSRDF involves two things, sampling an incoming direction and sampling a position where the incoming light enters the volume of the SSS object from the surface.
Sampling a direction is no different from sampling a direction using BRDF. As a matter of fact, PBRT uses a wrapper BXDF to hide the  $ S_w $ 
 part.
And with the BRDF setup, it easily reuses existed code infrastructure to sample it.</p>
<p>Taking a sample around the point to be shaded is a bit more complex than taking a random direction around the same point since it depends on the shape of the geometry.
There are numerous methods that can help to take samples. For example, in PBRT 2nd edition, they construct a KD-Tree for saving randomly generated points on the surface of the geometry.
When taking samples, the algorithm can take advantage of the KD-Tree to &lsquo;randomly&rsquo; pick nearby samples. The method that I choose to implement in my renderer is from this <a href="http://library.imageworks.com/pdfs/imageworks-library-BSSRDF-sampling.pdf">paper</a>,
which is also implemented in PBRT 3rd edition.
The basic idea is to assume the geometry is totally flat and randomly pick a sample on the disk that floats right above the shading point.
With the point picked on the disk, it then projects a ray (the green one) in the opposite direction of the surface normal at the shading point.
The intersection of the short ray with the original geometry will be the sampled point.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/projection.png" width="550"/>
</figure>

<p>In the above image,  $r_{max}$ 
 is decided by the diffusion profile. And r is a random sample based on the chosen pdf.
Luckily enough, the diffusion profile Disney offers in their <a href="https://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf">paper</a> already has a perfect pdf.
One detail to be noted here is that we should have three  $r_{max}$ 
 because the diffusion profile has three channels. Here I assume we are not doing the real spectrum rendering.
It is needed to pick one channel randomly first and having it taken into account eventually when evaluating its pdf.</p>
<p>The problem is more than what it appears to be in the above image. Whenever there is an assumption that breaks, problems arise.
Of course, the geometries won&rsquo;t be flat most of the time.
Depending on the geometry and diffusion profile, there could be multiple intersections instead of just one.
And also sometimes, when the projection ray is almost perpendicular to the geometry surface it intersects, it can result in fireflies.
Those problems are addressed in PBRT 3rd edition. Please check <a href="http://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Subsurface_Reflection_Functions.html">here</a> for further detail.</p>
<h2 id="how-does-it-fit-in-a-path-tracing-algorithm">How Does It Fit in a Path Tracing Algorithm</h2>
<p>In order to figure out how to integrate SSS implementation in a path tracer, it is necessary to know how a barebone path tracer works in general.
My previous <a href="https://agraphicsguynotes.com/posts/basics_about_path_tracing/">blog post</a> mentioned some basics about it.
Below is the pseudo-code of a minimal path tracer algorithm with BSSRDF in it.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>color li(scene, ray, max_bounce_cnt){
</span></span><span style="display:flex;"><span>    color ret(<span style="color:#ff0;font-weight:bold">0.0f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> bounces = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">auto</span> r = ray;
</span></span><span style="display:flex;"><span>    color throughput(<span style="color:#ff0;font-weight:bold">1.0f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span>( bounces &lt; max_bounce_cnt ){
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 1 - Get the intersection between the ray and the scene.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//     Bail if it hits nothing. This is commonly the place to return sky color,
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//     while it is skipped for simplicity since it is not relevant.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        Intersection intersection;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>( (intersection = get_intersect(scene, r)).IsInvalid() )
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 2 - Construct BSDF
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        intersection.bsdf = construct_bsdf(intersection);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 3 - Evaluate the contribution from light source
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        ret += evaluate_light(intersection) * throughput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 4 - Importance sample for the bounced ray
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">float</span> bsdf_pdf;
</span></span><span style="display:flex;"><span>        vector dir;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">auto</span> bsdf_evaluation = intersection.bsdf-&gt;sample_f(&amp;dir, &amp;bsdf_pdf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 5 - Update throughput
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        throughput *= bsdf_evaluation * dot(intersection.n, dir) / bsdf_pdf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 6 - Update the bounce ray
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        r = Ray(intersection.position , dir);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// This is where we handle BSSRDF
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span>(intersection.bssrdf){
</span></span><span style="display:flex;"><span>            &lt;&lt;&lt; Handle BSSRDF &gt;&gt;&gt;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 7 - Russian roulette. rand() returns value from 0 to 1 randomly and 
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//     the random samples are uniformly distributed.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span>(rand() &lt; <span style="color:#ff0;font-weight:bold">0.3f</span> &amp;&amp; bounces &gt; <span style="color:#ff0;font-weight:bold">3</span> )
</span></span><span style="display:flex;"><span>            throughput /= <span style="color:#ff0;font-weight:bold">0.3f</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ++bounces;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>PBRT&rsquo;s path tracing implementation is a lot more complex than the above code. But in order to keep things in control, I stripped the irrelevant parts with only the core left.
To make it clear, basically, it does the following things inside the loop (pretending that there is no bssrdf)</p>
<ol>
<li>For each ray, try getting the nearest intersection with the scene first. If the ray hits nothing, it will simply break out of the loop.</li>
<li>If there is an intersection found, it will construct bsdf, which commonly represents the material.</li>
<li>For a valid material, it will evaluate light contribution through the bsdf.</li>
<li>Importance sampling for the next ray based on the bsdf, this is essentially a greedy method.</li>
<li>Update the throughput value so that the contribution of the next light bounce will take this one into account.</li>
<li>Update the bounce ray.</li>
<li>Russian roulette to make things under control and unbiased.</li>
</ol>
<p>This above logic is the very essential core of a path tracing algorithm with lots of detailed implementation skipped, for example like multiple importance sampling, sky rendering, volumetric rendering, efficient Russian roulette, etc.
But this is more than enough as a playground for us to introduce how a BSSRDF can fit in it.
In the case there is bssrdf available, we only need to implement the branch of the condition.
Following is the code snippet of &lt;&lt;&lt; Handle BSSRDF &gt;&gt;&gt;.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">// Take a random sample by projecting a ray.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>Intersection bssrdf_intersection;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">float</span> bssrdf_pdf;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> bssrdf_evaluation = intersection.bssrdf-&gt;sample_s(scene, 
</span></span><span style="display:flex;"><span>                               &amp;bssrdf_pdf, &amp;bssrdf_intersection);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Bail if there is no intersection.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">if</span>(bssrdf_intersection.IsInvalid())
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Update the throughput
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>throughput *= bssrdf_evaluation / bssrdf_pdf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Evaluate direct illumination
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>ret += evaluate_light(intersection) * throughput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Take another sample of direction for the bounce ray.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">float</span> bsdf_pdf;
</span></span><span style="display:flex;"><span>vector dir;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> bsdf_evaluation = bssrdf_intersection.bsdf-&gt;sample_f(&amp;dir, &amp;bsdf_pdf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Update throughput
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>throughput *= bsdf_evaluation * dot(intersection.n, dir) / bsdf_pdf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Update the bounce ray
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>r = Ray(intersection.position , dir);
</span></span></code></pre></div><p>What it does is pretty self-explanatory. Below is a breakdown of computation it does in order to evaluate BSSRDF.</p>
<ul>
<li>It first takes a sampled position near the shading point. The importance sampling of the diffusion profile happens under the hood.
One important detail to be noted here is that the interface <strong>sample_s</strong> will silently add a fake brdf in the bsdf of the intersection for importance sampling the ray direction of the next iteration in the loop.</li>
<li>If nothing is found, it will simply bail. This will be a source of bias and it is why SSS evaluation tends to tint with a different color at the thin parts of the object.</li>
<li>Update the throughput, this line will count the attenuation caused by the distance between the shading point and sampled point. It is essentially  $ S_p(\omega_i, \omega_o) $ 
  mentioned previously. Please note that the first Fresnel part is already handled in the BXDF right before the condition.</li>
<li>Starting from here, we need to evaluate both direct illumination and indirect illumination to take both into account.
<ul>
<li>Direct illumination evaluation is fairly simple in the way that we can take advantage of the existed code infrastructure.</li>
<li>With the fake BRDF added previously, we can take a sample direction based on it. This direction will be used as the bounce ray for the next iteration in the loop.</li>
</ul>
</li>
</ul>
<p>There is a lot of mathematics to derive to further prove what the above code does makes sense.
However, this is not the purpose of this blog. Instead of focusing on the mathematical theory, I would prefer to talk more about the real engineering problems that I encountered during my implementation.
So I will stop introducing the basics here and move forward with talking about my iterations.</p>
<h1 id="enhancements">Enhancements</h1>
<p>After my functional integration of PBRT&rsquo;s subsurface scattering algorithm, I found that there are still more problems to solve.</p>
<ul>
<li>Sometimes there are too many fireflies.</li>
<li>One SSS material can&rsquo;t blend with other SSS materials.</li>
<li>Subsurface scattering implementation is not flexible enough to be blended with other BRDFs.</li>
<li>There is some space for better performance.</li>
</ul>
<p>It appears that <a href="https://www.cycles-renderer.org/">Cycles</a>, the internal offline renderer in <a href="https://www.blender.org/">Blender</a>, has a more robust implementation.
Luckily, Cycles is also an open-source project. So I spend quite some time digging into what they improved over my integration from PBRT.
With lots of iterations, my SSS implementation is a lot more robust than it was at the beginning.</p>
<h2 id="reduce-fireflies">Reduce Fireflies</h2>
<p>The first and most annoying issue that I would like to solve was the fireflies.
These fireflies won&rsquo;t simply go away as we bump up the number of samples per pixel.
With the SSS integration in my renderer, this was what I got at the beginning.
Please be noted that there is no coating layer and it is on purpose because I would like to avoid any other potential sources of fireflies.
This is already 1k samples and even by bumping the spp up to 8k, fireflies won&rsquo;t be totally gone, if not getting worse.
The firefly problem renders the algorithm impractical in my renderer since it is so obvious.
Of course, we can also rely on some post-processing, like a denoiser, to mitigate the problem.
But it would be nice to know what the sources of the problems are and fix them for real.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/iteration0.png" width="600"/>
</figure>

<h3 id="dont-evaluate-sss-unnecessarily">Don&rsquo;t Evaluate SSS Unnecessarily</h3>
<p>One observation that I made during my iteration was that the impact of SSS objects on its neighbors with SSS materials is very close to what a Lambert model has.
Taking the advantage of the assumption, I chose to silently replace SSS objects with lambert if the previous reflection model has SSS.
Below is a comparison of the same shot with and without the trick, the difference is barely noticeable to me.
It is worth mentioning that I clamped pixels with high radiance value to avoid fireflies in both shots.</p>







 
 
 
 




<style>
.ba-slidera88c3b9bbf4073074127b0afa2b16857 {
    position: relative;
    overflow: hidden;
    width: 100%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-slidera88c3b9bbf4073074127b0afa2b16857 img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-slidera88c3b9bbf4073074127b0afa2b16857 .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-slidera88c3b9bbf4073074127b0afa2b16857 .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-slidera88c3b9bbf4073074127b0afa2b16857 .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-containera88c3b9bbf4073074127b0afa2b16857 {
    position: relative;
    text-align: center;
}

.ba-bottom-lefta88c3b9bbf4073074127b0afa2b16857,
.ba-bottom-righta88c3b9bbf4073074127b0afa2b16857 {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-lefta88c3b9bbf4073074127b0afa2b16857 {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-righta88c3b9bbf4073074127b0afa2b16857 {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-slidera88c3b9bbf4073074127b0afa2b16857" id="ba-slider-a88c3b9bbf4073074127b0afa2b16857">
        <div class="ba-containera88c3b9bbf4073074127b0afa2b16857">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/regular_sss.png">
            <div class="ba-bottom-righta88c3b9bbf4073074127b0afa2b16857">Allow SSS to SSS bounces</div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/disconnect_sss.png">
            <div class="ba-bottom-lefta88c3b9bbf4073074127b0afa2b16857">Disallow SSS to SSS bounces</div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-lefta88c3b9bbf4073074127b0afa2b16857');
    var rightLink = container.find('.ba-link-righta88c3b9bbf4073074127b0afa2b16857');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-a88c3b9bbf4073074127b0afa2b16857').beforeAfter();
</script>

<p>Clearly, this will avoid some importance sampling of BSSRDF and converts a BSSRDF to a simple lambert model.
Most BXDF importance sampling algorithms are commonly done locally without the knowledge of the surroundings.
Importance sampling algorithm used to randomly sample points on its nearby surfaces in this SSS implementation involves shooting short rays.
This is easily an order of magnitude more expensive than BXDF&rsquo;s importance sampling algorithm.
However, given the rare cases where there are two consecutive SSS bounces in the same path, the differences in terms of computation in a practical scene like the above are close to minimal.
In some cases where SSS surfaces face each other, there is a greater chance for a path to have multiple consecutive samples on the same mesh with SSS. For example, like the one shown below.
Even in these cases, the performance gain is not too much, roughly 10% reduction in rendering speed.
However, the biggest gain in terms of performance is that it opens a door for our next iteration by making it possible, which we will cover later.</p>







 
 
 
 




<style>
.ba-sliderdc405557b70643524e0e792520a81a8c {
    position: relative;
    overflow: hidden;
    width: 70%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-sliderdc405557b70643524e0e792520a81a8c img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-sliderdc405557b70643524e0e792520a81a8c .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-sliderdc405557b70643524e0e792520a81a8c .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-sliderdc405557b70643524e0e792520a81a8c .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-containerdc405557b70643524e0e792520a81a8c {
    position: relative;
    text-align: center;
}

.ba-bottom-leftdc405557b70643524e0e792520a81a8c,
.ba-bottom-rightdc405557b70643524e0e792520a81a8c {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-leftdc405557b70643524e0e792520a81a8c {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-rightdc405557b70643524e0e792520a81a8c {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-sliderdc405557b70643524e0e792520a81a8c" id="ba-slider-dc405557b70643524e0e792520a81a8c">
        <div class="ba-containerdc405557b70643524e0e792520a81a8c">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/iteration1.png">
            <div class="ba-bottom-rightdc405557b70643524e0e792520a81a8c">After</div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/iteration0.png">
            <div class="ba-bottom-leftdc405557b70643524e0e792520a81a8c">Before</div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-leftdc405557b70643524e0e792520a81a8c');
    var rightLink = container.find('.ba-link-rightdc405557b70643524e0e792520a81a8c');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-dc405557b70643524e0e792520a81a8c').beforeAfter();
</script>

<p>The above two shots are rendered both with 1024 samples per pixel. We can easily notice that the optimization turns out to be very effective in terms of reducing fireflies, which was my primary reason for considering implementing it at the cost of slightly extra biased results.
Even with the SPPs bumped to 8k, the fireflies still doesn&rsquo;t go away in the original implementation.
With the optimization, it almost gets rid of more than 90% of the total fireflies at no performance cost.
And we saw from the bunny example, it doesn&rsquo;t have a big impact on the final result.
Of course, we can argue that the SSS to SSS bounces is not as many as it is in this example, the visual comparison of those shots may not represent the biggest potential bias we could eventually get.
But since the SSS algorithm has some pretty aggressive assumptions made at the very beginning, I would be willing to sacrifice a bit of accuracy to implement a reasonable SSS algorithm with limited fireflies.</p>
<h4 id="what-happens-under-the-hood">What Happens Under the Hood</h4>
<p>I think it is worth a little bit of explanation here to make it clear why such a trick can get rid of the majority of the fireflies.
To answer the question, it is necessary to figure out where do these fireflies come from?
By taking a deeper look into what happens here, I noticed that the volume inside the outer ball is not empty at all. It has multiple layers of geometries.
Following is a demonstration of what could happen inside the volume of the outer ball.
Of course, there are no three parallel surfaces in the outer ball mesh, but it does lead to rays bouncing between its surfaces, so this representation doesn&rsquo;t lose its generality.
Upon the first intersection of the primary ray, it will pick three samples on the surface of the objects, some of which happen to be inside the volume and is kind of unfortunate.
It is unfortunate because the next sample it picks will also be from the exact same material with SSS.
As we can see from the path  $ P_0 \rightarrow P_{11} \rightarrow P_{2} \rightarrow P_{31} \rightarrow P_{4} \rightarrow P_{5} \rightarrow P_{63}$ 
 , which is essentially three bounces.
Please be noted that the transition from  $ P_0 $ 
 to  $ P_{11} $ 
 is not considered a bounce, it is just taking a sample of BSSRDF. Same goes true about the transition from  $ P_5 $ 
 to  $ P_{63} $ 
 .
The real problem behind this is that every single path is trying to make its way out, while only a very minority group of lucky paths will make it.
However, the ones made out will make an excessive amount of contribution to the evaluation since their PDF is extremely low.
In practice, the situation is way worse than just a few bounces.
I think there are a few reasons for this problem,</p>
<ul>
<li>Unnecessary complex internal structure of the outer ball.
There is no real solution for this unless we ask data authors to change the way they do things, which could be a big limitation to artists.</li>
<li>The distance profile is nowhere near being physically accurate.
There is also no easy solution for this one. It because is those bold assumptions that make this algorithm feasible.</li>
<li>Importance sampling does not always stick to the target function, which is the distance profile.
Although the Disney distance profile can be analytically sampled with a perfect PDF, the unknown shape of geometry easily makes the sampling algorithm less efficient. We will cover it later.</li>
</ul>
<p>Replacing SSS with lambert if the previous material has SSS will almost prevent this from happening. Because the path will be blocked when going from  $ P_{11} $ 
 to  $ P_2 $ 
 .
Rays won&rsquo;t bounce between complex meshes with SSS materials.
Of course, light does bounce between complex shapes with SSS materials in reality, but without a good importance sampling algorithm and distance profile, this will easily lead to fireflies.
And considering the multi-bounces inside SSS materials don&rsquo;t have the biggest impact on the final visual, I chose to ignore it by replacing SSS with lambert if necessary.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/bounces_diagram.png"/>
</figure>

<h4 id="the-catch-of-replacing-sss-with-lambert">The Catch of Replacing SSS with Lambert</h4>
<p>Given a specific path, depending on the direction of evaluation, the end result of rendering equation evaluation could be different.
Imagine there is a path like this
 $ E \rightarrow A \rightarrow B \rightarrow L $ 
 ,
where <strong>E</strong> stands for eye, <strong>A</strong> and <strong>B</strong> stand for two points on surfaces with SSS, <strong>L</strong> represents light. If the direction of evaluation is from the eye to the light, <strong>A</strong> will be evaluated with SSS model, but <strong>B</strong> will be a lambert model.
While if the direction of the evaluation goes the other way, <strong>B</strong> will be evaluated with SSS, and <strong>A</strong> will be simplified with lambert model. This clearly introduces some bias between path evaluation from different directions.
This might not be a problem at all for unidirectional path tracing or light tracing, where evaluation is always one direction. For algorithms like bidirectional path tracing, this will introduce an extra layer of bias.
Same reason here, considering the multiple sources of biases in the algorithm, I don&rsquo;t mind having another one here.</p>
<h3 id="evaluate-at-all-intersections">Evaluate at all Intersections</h3>
<p>The above-mentioned trick allows the algorithm renders with SSS in a way that converges a lot faster.
Clearly, this is not a flawless solution since there are still quite some fireflies in the shot.
These fireflies must come from other sources in the sampling process.</p>
<p>Fireflies commonly show up whenever the importance sampling algorithm is not very efficient.
In the beginning, I didn&rsquo;t choose to believe it since that diffusion profile from the Disney <a href="https://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf">paper</a> has a perfect pdf function.
However, after taking a deeper look into the process, I found a problem that could cause it.</p>
<p>There are clearly some other factors that will affect the efficiency of the importance sampling, like the light source.
It would be very hard, if not impossible, to take lights into account when taking samples with importance sampling algorithm.
But the multi-intersection nature of the algorithm does lead to some problems.
Like we mentioned before, there is a possibility that the projection ray will hit multiple surfaces with the same objects, instead of just one.
In these cases, PBRT will choose to uniformly pick one random intersection and divide the diffusion profile PDF by the number of intersections that the short ray hits in total.
This essentially adds a weighting factor for the original pdf.
Mathematically, the final pdf should be as below,</p>

$$ P(X,R) = P_{Disney}(R) * P_{uniform}(X|R=r)$$
<p>R is the distance between the sampled point on the disk to the center of the disk.
X is the index of the point it picks among all intersections.
So we can clearly see from this equation, the Disney importance sampling pdf is just one part of the final pdf we have. The second pdf uniformly takes one intersection among all randomly, it is a conditional probability distribution.
And it is the efficiency of the final pdf that matters. Even if the first pdf is a perfect match of the original diffusion profile, the second extra pdf does have a chance to make it way less efficient. Not to mention, the first pdf is only a perfect pdf considering flat surfaces.</p>
<p>To explain it in a more intuitive way, if we look at the image below.
The chances of sampling both red and green short rays are exactly the same since their distance to the center of the disk is the same.
However, we have five times more chances of picking the red point than any of the green ones even if the red point has more distance compared with any of the green ones.
To manually make things worse, if we place a light source near one of the green dots.
We will have a much bigger contribution by picking the green dot that is near to the light source with a five times lower chance of picking it.
This is a very typical example of why this importance sampling algorithm is not efficient in some cases. It can even get worse in practical situations.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/diagram_multi_intersection.png" width="700px"/>
</figure>

<p>It would be very hard to uniformly sample all intersections in this algorithm globally since we don&rsquo;t know how many intersections there will be in total.
The truth is there is not even a number, it is a continuous domain.
But one thing that we can do to mitigate the problem is to avoid randomly picking one intersection among all but to evaluate all of them.
This was not possible before the first iteration since rays will grow exponentially without the above trick.
But since I have it implemented, I can totally consider evaluating all intersections instead of just randomly picking one of them.
Following is a comparison of the shots with and without this method, it is obvious how efficient it is after this iteration.
It is worth noting that instead of having the same spp this time, I choose to configure the settings differently so that the rendering time is roughly the same, which makes the comparison fairer.</p>







 
 
 
 




<style>
.ba-slidera83234c266e188debc03a310fe6b6382 {
    position: relative;
    overflow: hidden;
    width: 70%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-slidera83234c266e188debc03a310fe6b6382 img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-slidera83234c266e188debc03a310fe6b6382 .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-slidera83234c266e188debc03a310fe6b6382 .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-slidera83234c266e188debc03a310fe6b6382 .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-containera83234c266e188debc03a310fe6b6382 {
    position: relative;
    text-align: center;
}

.ba-bottom-lefta83234c266e188debc03a310fe6b6382,
.ba-bottom-righta83234c266e188debc03a310fe6b6382 {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-lefta83234c266e188debc03a310fe6b6382 {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-righta83234c266e188debc03a310fe6b6382 {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-slidera83234c266e188debc03a310fe6b6382" id="ba-slider-a83234c266e188debc03a310fe6b6382">
        <div class="ba-containera83234c266e188debc03a310fe6b6382">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/iteration2.png">
            <div class="ba-bottom-righta83234c266e188debc03a310fe6b6382">After</div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/iteration1.png">
            <div class="ba-bottom-lefta83234c266e188debc03a310fe6b6382">Before</div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-lefta83234c266e188debc03a310fe6b6382');
    var rightLink = container.find('.ba-link-righta83234c266e188debc03a310fe6b6382');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-a83234c266e188debc03a310fe6b6382').beforeAfter();
</script>

<p>Given the result of the shot, I can hardly tell any firefly in it. This is already a firefly free solution to me.</p>
<h2 id="no-fresnel-above-sss-material">No Fresnel above SSS material</h2>
<p>It is common that renderers will introduce a coating layer to simulate a glossy surface with SSS under it to deliver a wax-like feeling. PBRT uses fresnel to pursue better physically-based accuracy. But it is also not uncommon to see articles mentioning SSS without the fresnel part. Strictly speaking, subsurface scattering should have no connection with the coating layer since they are not tightly couple all the time.
Also, because I have my plan to support flexible blending between bssrdf and bxdf in my material system, which will be covered later in this blog, I can totally approximate the fresnel part in my shader, instead of hardcode it in the bssrdf.</p>
<p>Ideally, my goal here is to make sure I can guarantee this equation,</p>

$$ \lim\limits_{s \rightarrow 0} \int_A \int_{\Omega} L(p_i, \omega_i) \space bssrdf( s, \omega_i, \omega_o ) cos(\theta_i) d\omega_i dA = \int_{\Omega} L(\omega_i) \space brdf_{lambert}(\omega_i, \omega_o) cos(\theta_i) d\omega_i$$
<p>The benefit of securing such an equation is that it allows me to have a proper transition between sss and lambert model without introducing a noticeable boundary in between.
This doesn&rsquo;t sound like a big deal, but it does offer a bit more flexibility of data authoring.
For example, the shots below clearly demonstrate the differences. The mean free path goes to zero gradually as the position goes lower, eventually reaching zero somewhere around the neck of the monkey head. It is not too obvious, but we can notice the line at the bottom of the monkey head by taking a closer look. This is because the above equation is not true for the original implementation.</p>







 
 
 
 




<style>
.ba-slider0662fea70917668a921a23d43c10e1da {
    position: relative;
    overflow: hidden;
    width: 70%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-slider0662fea70917668a921a23d43c10e1da img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-slider0662fea70917668a921a23d43c10e1da .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-slider0662fea70917668a921a23d43c10e1da .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-slider0662fea70917668a921a23d43c10e1da .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-container0662fea70917668a921a23d43c10e1da {
    position: relative;
    text-align: center;
}

.ba-bottom-left0662fea70917668a921a23d43c10e1da,
.ba-bottom-right0662fea70917668a921a23d43c10e1da {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-left0662fea70917668a921a23d43c10e1da {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-right0662fea70917668a921a23d43c10e1da {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-slider0662fea70917668a921a23d43c10e1da" id="ba-slider-0662fea70917668a921a23d43c10e1da">
        <div class="ba-container0662fea70917668a921a23d43c10e1da">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/transition0.png">
            <div class="ba-bottom-right0662fea70917668a921a23d43c10e1da">Smooth Transition</div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/transition1.png">
            <div class="ba-bottom-left0662fea70917668a921a23d43c10e1da">No Smooth Transition</div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-left0662fea70917668a921a23d43c10e1da');
    var rightLink = container.find('.ba-link-right0662fea70917668a921a23d43c10e1da');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-0662fea70917668a921a23d43c10e1da').beforeAfter();
</script>

<p>The way I achieve this smooth transition is by killing the two Fresnel parts and adding a denominator of $ \pi $. So the equation of my BSSRDF goes like this,</p>

$$ S(p_o, p_i, \omega_o, \omega_i) \approx \dfrac{S_p(p_o, p_i)}{\pi} $$
<p>As the mean free path length approaches to zero, the  $S_p(p_o, p_i)$ 
 becomes linearly proportional to <a href="https://en.wikipedia.org/wiki/Dirac_delta_function">dirac-delta</a> function. Also, as we know, a dirac-delta function will simplify integral in Monta Carlo estimation by dropping one dimension. The constant factor is what we need to figure out here. Since the pdf, which is proportional to this BSSRDF, the only difference between this BSSRDF and the pdf is the color tint part. Because when the mean free path approaches zero, it is very likely there is only one single intersection. This means that we don&rsquo;t need to take the conditional probability density function into account. So the pdf and bssrdf have this connection</p>

$$ S_p(p_o, p_i) = A * p(p_o,p_i) $$
<p>By taking a look at the Monte Carlo estimation, we got this</p>

$$ \lim\limits_{s \rightarrow 0} S(p_o, p_i, \omega_o, \omega_i) \approx \lim\limits_{s \rightarrow 0} \Sigma {\dfrac{S_p(p_o, p_i)}{p(p_o,p_i)}} = \dfrac{A}{\pi} $$
<p>And dropping this equation back to the one we want to fulfill, it is obvious that this is a perfect match, which is also proved by the above shot.</p>
<h2 id="avoid-finding-intersection-with-other-meshes">Avoid Finding Intersection with other Meshes</h2>
<p>One detail in SSS implementation is to tell whether an intersection is a valid one during importance sampling of nearby positions.
PBRT considers it a valid intersection as long as the material is the same. In case there are two meshes with the same SSS material, they will find intersections on each other, which will result in incorrect approximation.</p>
<p>In my renderer, I chose to instance subsurface scattering materials so that each mesh object has its own material instance with a unique id. This will avoid the problem. A material instance is just a thin wrapper of the original material, the memory overhead is close to minimal in most cases.</p>
<h2 id="refactor-material-system-in-my-renderer">Refactor Material System in my Renderer</h2>
<p>Prior to implementing sss in my renderer, it used to only have a linear combination of BXDFs in a data structure called BSDF. Strictly speaking, it is not just linearly blended BXDFs, since some BRDF, like Coat, can take a BSDF as an input argument. This converts the data into a tree. But this is irrelevant to the topic in this blog, we can ignore it.
To extend the system with sss features, I added a pointer for each material so that they can access more than BSDF data.
This can be easily integrated in the above pseudo-code. However, there are some limitations with this implementation.</p>
<ul>
<li>If a material has BSSRDF, it won&rsquo;t be allowed to have other BXDF that is not relevant. The algorithm won&rsquo;t work very well. It will always pick BSSRDF if one existed. This limitation means that we can&rsquo;t blend BSSRDF with other BXDF stored in the BSDF.</li>
<li>The system can only have one single BSSRDF since there is only one single pointer holding it. But sometimes, we might want to have multiple diffusion profiles blended together to achieve better subsurface scattering results, like skin rendering. The current system clearly doesn&rsquo;t offer this flexibility.</li>
</ul>
<p>In order to support flexible blending between BXDF and BSSRDF, I chose to refactor my material system. As we know that BSSRDF is a generalized version of BXDF. One option would be to derive all BXDF implementations from BSSRDF. This does stick to the truth in reality, but it immediately raised some problems in terms of coding. I don&rsquo;t particularly like the design of this idea for two reasons</p>
<ul>
<li>The interface will be fatter with more arguments since we have more dimensions in BSSRDF. It might lead to less performance due to more arguments in call stack and in most cases where there is no subsurface scattering, lots of the arguments are not even used at all.</li>
<li>The path tracing, bidirectional path tracing algorithms will have to treat everything like a BSSRDF, which won&rsquo;t be efficient in terms of performance.</li>
</ul>
<p>Eventually, I ended up with the other solution, both BXDF and BSSRDF derive from what I call scattering unit. All scattering units are held in a structure named scattering event, which is what I used to replace BSDF in my old system. The biggest difference introduced here is that scattering event can also hold multiple BSSRDFs along with BXDFs. A subtle difference here is that instead of holding an array of scattering units, the scattering event data structure chooses to hold two separate arrays, with one for BXDFs and the other for BSSRDFs, since they behave very differently compared with each other. This way it allows me to put the interfaces of BXDF and BSSRDF one level lower than their base class.</p>
<figure><a href="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/class_diagram.png"><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/class_diagram.png"/></a>
</figure>

<p>Above is a simplified class diagram that demonstrates what I implemented in my renderer.
It doesn&rsquo;t have everything I have done in it. For example, there are only three BRDFs shown in this diagram, while I have implemented a lot more than this.
However, it gives a good explanation of what the big picture is.</p>
<p>Again, there are a few adjustments needed to be done in my path tracing algorithm</p>
<ul>
<li>In the third step shown in my pseudo-code, where we used to only evaluate BRDFs. We can choose to randomly pick one scattering unit from scattering event. The scattering unit can be either a BXDF or a BSSRDF. If a BXDF is chosen, we still stick to the old path. In the case of a BSSRDF chosen, the new algorithm will pick sampled positions and evaluate all of them to approximate the contribution from direct illumination.</li>
<li>Just like what we did for step 3, we need to do similar things for step 4, where we used to only take direction samples from BXDF. Again, we randomly choose to have one scattering unit among all in the scattering event. If a BSSRDF is chosen, we first randomly pick a sampled position based on the BSSRDF model, and then we will recursively evaluate the indirect illumination for this part.</li>
</ul>
<p>These two steps are what I eventually did in my renderer. But I guess it is also possible to merge the two steps in one by randomly picking between BXDF and BSSRDF once. Once one is picked, we use the type for both evaluation and importance sampling. I haven&rsquo;t tried it in my renderer, it sounds to me it could work. There might be other problems though.</p>
<p>Ideally, I would like to put the pseudo-code here too.
But in order to avoid a too much longer post, I chose to skip it since it is not that hard to implement.
For anyone, who is interested, <a href="https://github.com/JiayinCao/SORT/blob/master/src/integrator/pathtracing.cpp">here</a> is the implementation in my renderer.</p>







 
 
 
 




<style>
.ba-sliderade1b6f1ca02a923b999c7d0c1bbb77d {
    position: relative;
    overflow: hidden;
    width: 100%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-sliderade1b6f1ca02a923b999c7d0c1bbb77d img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-sliderade1b6f1ca02a923b999c7d0c1bbb77d .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-sliderade1b6f1ca02a923b999c7d0c1bbb77d .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-sliderade1b6f1ca02a923b999c7d0c1bbb77d .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-containerade1b6f1ca02a923b999c7d0c1bbb77d {
    position: relative;
    text-align: center;
}

.ba-bottom-leftade1b6f1ca02a923b999c7d0c1bbb77d,
.ba-bottom-rightade1b6f1ca02a923b999c7d0c1bbb77d {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-leftade1b6f1ca02a923b999c7d0c1bbb77d {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-rightade1b6f1ca02a923b999c7d0c1bbb77d {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-sliderade1b6f1ca02a923b999c7d0c1bbb77d" id="ba-slider-ade1b6f1ca02a923b999c7d0c1bbb77d">
        <div class="ba-containerade1b6f1ca02a923b999c7d0c1bbb77d">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/digital_emily_1.png">
            <div class="ba-bottom-rightade1b6f1ca02a923b999c7d0c1bbb77d">Multiple SSS</div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/digital_emily_0.png">
            <div class="ba-bottom-leftade1b6f1ca02a923b999c7d0c1bbb77d">Single SSS</div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-leftade1b6f1ca02a923b999c7d0c1bbb77d');
    var rightLink = container.find('.ba-link-rightade1b6f1ca02a923b999c7d0c1bbb77d');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-ade1b6f1ca02a923b999c7d0c1bbb77d').beforeAfter();
</script>

<p>Above is an example that uses this feature to implement a skin shader. The comparison is single subsurface scattering versus multiple subsurface scattering.
The difference is very subtle, but it is visible in the dark area on her face.
Also, apart from blending subsurface scattering, this material also blends sss with regular brdf to simulate a bit of specular light on her face.
Below is the shader graph of this material used to render the shot. Click it for an enlarged image if it is not clear enough.</p>
<figure><a href="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/shader_graph.png"><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/shader_graph.png"/></a>
</figure>

<h1 id="optimizations">Optimizations</h1>
<p>Besides the enhancements that I did in my implementation, I also made a couple of optimizations that purely aim at improving performance. They don&rsquo;t contribute to convergence rate or image quality that much, but making things faster is already a good reason to check them in.</p>
<h2 id="intersection-tests">Intersection tests</h2>
<p>SSS implementation mentioned in this blog requires finding the intersections with K nearest primitives. A naive way to get it done without introducing more complexity is to find the nearest intersection first and then adjust the ray origin a little bit off the surface along the ray direction, get the next intersection. The process keeps going until either K nearest intersections are found or it exceeds the allowed range of our interest.
This naive implementation is simple in the way that it doesn&rsquo;t require any changes in the spatial acceleration structure. The algorithm to find the K nearest intersection is totally limited in SSS implementation itself. While it does comes at a cost of performing duplicated evaluation multiple times. Imagine in a case, where there are only five primitives in a leaf node, all of which intersect with the ray to be tested, and they are also the first five intersections. If our K is 4 in this case, we will have to perform the ray primitive intersection 20 times just to get the nearest 4 intersections in this leaf. This doesn&rsquo;t even count the workload to iterate the traversal to the leaf node, which is also duplicated by 4 times.</p>
<p>A slightly advanced approach to solving this problem is to introduce a dedicated interface to return K nearest intersections along the ray. This does require keeping a list of intersection history, which takes a bit of extra memory during intersection evaluation.
But it efficiently avoids all the above-mentioned duplicated computation during finding the K nearest intersections.  In my renderer, I chose to implement the algorithm in all of my spatial data structures, including kd-tree, BVH, OBVH, QBVH, uniform grid, octree.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/cartoon_head.png"/>
</figure>

<p>Above is another example generated in my renderer.
A big proportion of the image is covered by skin, which is essentially this subsurface scattering model.
But apart from these skin pixels, there are also other materials like metal, hair, and even a different primitive type.
In such a scene, this optimization reduces the total intersection by 14%, eventually improves the final rendering performance by 11.5%. For a pure subsurface scattering scene like the monkey head shot, performance gain can be as high as 14%.</p>
<h2 id="avoid-mis">Avoid MIS</h2>
<p>Whenever we find an intersection to keep iterating, we need to evaluate how much light coming in through that exit point.
Normally, we will take multiple samples from both light sources and the BRDF to avoid bad sampling, which could be caused by either a spiky shape BRDF or a tiny light source.
But we know for a fact that the BRDF here is lambert, there is no need to take samples from BRDF at all.
The <a href="http://cseweb.ucsd.edu/~viscomp/classes/cse274/wi18/readings/veach_thesis.pdf">thesis</a> that introduced multiple importance sampling already made it clear that MIS doesn&rsquo;t necessarily improve quality all the time.
We can simply take advantage of this to avoid taking unnecessary samples.
Taking samples from light sources works simply well enough.</p>
<p>Ideally, this should get less shadow ray since MIS will require two separate shadow ray to be shot while sampling the light source only needs one. And this should mean that we have less computation to do.
Also, in the case of very small area light sources, MIS may have a slightly worse result than sampling light direction only since sampling from lambert brdf will almost always miss the light source.
However, my experimental data doesn&rsquo;t indicate too much gain from this optimization. I still kept it in my renderer since I can&rsquo;t justify any reason to take samples from brdf in this case and at least it doesn&rsquo;t hurt anything.</p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>Apart from the above few optimizations I made, there are also some minor optimizations I did in my renderer.
They are not that important, but it is nice to have since they are fairly easy to implement.</p>
<ul>
<li><strong>Ignore SSS after too many paths</strong><br>
Just like we have the maximum bounces of the main path, we can totally have another sperate control purely over subsurface scattering materials. This is just another finer control over the system.</li>
<li><strong>Avoid generating SSS when mean free path is 0 in all channels</strong> <br>
Generally, subsurface scattering evaluation has a different branch in path tracing algorithm, which is more expensive in terms of performance. With the proper transition feature, I would prefer to silently replace them with lambert whenever mean free paths are zero. This is no catch of doing so.<br>
Another further optimization could be partially replacing subsurface scattering with lambert when the corresponding channel has mean free path that is zero. This idea takes advantage of the blending system that I did in my render so that it can blend a lambert with a subsurface scattering together.</li>
</ul>
<h1 id="a-failed-attempt">A Failed Attempt</h1>
<p>A more aggressive way is to ignore SSS from all BRDFs without spiky shapes, like lambert.
This might sound like a reasonable optimization at the beginning. But it will destroy some nice things SSS delivers, like the color tint in the shadow of the second shots I showed in this blog.
A more extreme case is like the two shots below.
Though these are not the best demo cases for showing SSS features since both of the spheres look fairly flat. But it does clearly demonstrates the potential problem that could result from such aggressive optimization.
With a concrete wall roughly in the middle of the Cornell box, the sphere with SSS material is pretty much the only way that light can path through from the right side of the Cornell box to the left side.
If we ignore SSS from all non-spiky shape BRDF, we will lose all light contribution on the left side of the Cornell Box. Another slight subtle difference is the top right corner gets a bit stronger bounced light contribution. This is probably because SSS will lose some energy when it fails to find samples on the surface of the same mesh object.
I can&rsquo;t say I care too much about the brighter bounce, but I definitely don&rsquo;t like losing the nice feature of allowing light penetrating through SSS objects. Eventually, I didn&rsquo;t choose to implement this in my renderer.</p>







 
 
 
 




<style>
.ba-slider5d0af1e7f834029ae9f0b50b5b49da21 {
    position: relative;
    overflow: hidden;
    width: 70%;
    margin: auto;
    background-color: #FFFFFF;  
}

.ba-slider5d0af1e7f834029ae9f0b50b5b49da21 img {
    width: 100%;
    display: block;
    max-width: none;
}

.ba-slider5d0af1e7f834029ae9f0b50b5b49da21 .resize {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 50%;  
    overflow: hidden;
}

.ba-slider5d0af1e7f834029ae9f0b50b5b49da21 .handle {
    position: absolute;
    left: 50%;  
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(0, 0, 0, 0.4);
    cursor: ew-resize;
    z-index: 20;
    transition: background-color 0.3s ease;
}
.ba-slider5d0af1e7f834029ae9f0b50b5b49da21 .handle:after {
    content: '';
    position: absolute;
    top: 50%;
    margin-top: -32px;
    margin-left: -4px;
    width: 10px;
    height: 64px;
    background: #808080;
}

.ba-container5d0af1e7f834029ae9f0b50b5b49da21 {
    position: relative;
    text-align: center;
}

.ba-bottom-left5d0af1e7f834029ae9f0b50b5b49da21,
.ba-bottom-right5d0af1e7f834029ae9f0b50b5b49da21 {
    position: absolute;
    bottom: 8px;
    font-weight: bold;
    white-space: nowrap;
}

.ba-bottom-left5d0af1e7f834029ae9f0b50b5b49da21 {
    left: 16px;
    color: #FFFFFF;  
}
.ba-bottom-right5d0af1e7f834029ae9f0b50b5b49da21 {
    right: 16px;
    color: #FFFFFF;  
}

 

</style>

<figure class="custom-compare">
    <div class="ba-slider5d0af1e7f834029ae9f0b50b5b49da21" id="ba-slider-5d0af1e7f834029ae9f0b50b5b49da21">
        <div class="ba-container5d0af1e7f834029ae9f0b50b5b49da21">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/cornell_sss_wrong.png">
            <div class="ba-bottom-right5d0af1e7f834029ae9f0b50b5b49da21">No SSS after Lambert</div>
        </div>
        <div class="resize">
            <img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/cornell_sss.png">
            <div class="ba-bottom-left5d0af1e7f834029ae9f0b50b5b49da21">Regular</div>
        </div>
        <span class="handle"></span>

        
        
    </div>
    
</figure>


<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" crossorigin="anonymous"></script>


<script>
(function($) {
  function drags(dragElement, resizeElement, container) {
    dragElement.on('mousedown.ba touchstart.ba', function(e) {
      dragElement.addClass('ba-draggable');
      resizeElement.addClass('ba-resizable');

      var startX = e.pageX || e.originalEvent.touches[0].pageX;
      var dragWidth = dragElement.outerWidth(),
          posX = dragElement.offset().left + dragWidth - startX,
          containerOffset = container.offset().left,
          containerWidth = container.outerWidth();

      var minLeft = containerOffset + 10;
      var maxLeft = containerOffset + containerWidth - dragWidth - 10;

      dragElement.parents().on("mousemove.ba touchmove.ba", function(e) {
        var moveX = e.pageX || e.originalEvent.touches[0].pageX;
        var leftValue = moveX + posX - dragWidth;

        if (leftValue < minLeft) leftValue = minLeft;
        else if (leftValue > maxLeft) leftValue = maxLeft;

        var percentage = (leftValue + dragWidth / 2 - containerOffset) * 100 / containerWidth + '%';

        dragElement.css('left', percentage);
        resizeElement.css('width', percentage);

        updateLinks(container, dragElement);
      }).on('mouseup.ba touchend.ba touchcancel.ba', function() {
        dragElement.removeClass('ba-draggable');
        resizeElement.removeClass('ba-resizable');
        $(this).off('.ba');
      });

      e.preventDefault();
    });
  }

  function updateLinks(container, handle) {
    var containerWidth = container.outerWidth();
    var handleLeft = handle.position().left;

    var leftLink = container.find('.ba-link-left5d0af1e7f834029ae9f0b50b5b49da21');
    var rightLink = container.find('.ba-link-right5d0af1e7f834029ae9f0b50b5b49da21');

    var deadZone = 20; 

    leftLink.css({
      width: Math.max(0, handleLeft - deadZone) + 'px'
    });

    rightLink.css({
      width: Math.max(0, containerWidth - handleLeft - deadZone) + 'px',
      left: (handleLeft + deadZone) + 'px'
    });
  }

  $.fn.beforeAfter = function() {
    var container = $(this);
    var handle = container.find('.handle');
    var resize = container.find('.resize');

    var width = container.width();
    resize.find('img').css('width', width + 'px');

    drags(handle, resize, container);
    updateLinks(container, handle);

    $(window).on('resize', function() {
      var width = container.width();
      resize.find('img').css('width', width + 'px');
      updateLinks(container, handle);
    });
  }
})(jQuery);

$('#ba-slider-5d0af1e7f834029ae9f0b50b5b49da21').beforeAfter();
</script>

<p>Even if I would like to implement it, there is another problem. It is not entirely straightforward to categorize materials based on how rough they are.
PBRT has a hardcoded category for each of its BRDF. However, the ones like measured BRDF, will be very difficult to be hardcoded.
Not to mention there are things like Disney BRDF, which offers lots of flexibility with a gradual transition from being rough to smooth.
An even more extreme case is a rough material with a smooth coating layer on top.
There is just not a clear boundary between rough materials and smooth ones.</p>
<h1 id="summary">Summary</h1>
<p>In this blog, I mentioned my iterations during implementing subsurface scattering.
These iterations allow me to render subsurface scattering in a more efficient way.
Apart from the common subsurface scattering materials, like skin, wax, this algorithm can also be used to approximate juice sometimes, like in the image below. I believe there could be a better way to render this, but it is always good to know more applications of the algorithm.</p>
<figure><img src="/img/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/orange_juice.png" width="700"/>
</figure>

<p>However, there are still some unsolved problems remained and potential improvements to be done in the future,</p>
<ul>
<li>A separate spatial structure for each object with subsurface scattering will skip all of the traversal steps from the root all the way to the interior node that holds the object.</li>
<li>It is not hard to notice that this algorithm will fail to converge to the correct result when the geometry is thin. For example, the head of the dragon shot is a bit dark because most short rays end up finding nothing, while they still have valid pdf. Somehow, Cycles solved the problem, it would be worth investigating.</li>
<li>Subsurface scattering is not supported in my bidirectional path tracing algorithm. Adding support to it does sound challenging since bdpt is not an easy algorithm to start with. Making sure all MIS weights are correct while adding sss would be difficult.</li>
<li>There are also numerous other methods for rendering subsurface scattering, like random walk sss. It would be fun to dive into the other algorithms and know the trade-off of these algorithms too.</li>
</ul>
<h1 id="referencess">Referencess</h1>
<p>[1] <a href="https://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf">Approximate Reflectance Profiles for Efficient Subsurface Scattering</a><br>
[2] <a href="http://library.imageworks.com/pdfs/imageworks-library-BSSRDF-sampling.pdf">BSSRDF Importance Sampling</a><br>
[3] <a href="https://pbrt.org/">Physically based rendering</a><br>
[4] <a href="https://graphics.stanford.edu/papers/bssrdf/bssrdf.pdf">A Practical Model for Subsurface Light Transport</a><br>
[5] <a href="http://www.iryoku.com/separable-sss/downloads/Separable-Subsurface-Scattering.pdf">Separable Subsurface Scattering</a><br>
[6] <a href="https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin">Advanced Techniques for Realistic Real-Time Skin Rendering</a><br>
[7] <a href="https://www.cycles-renderer.org/">Cycles Renderer</a><br>
[8] <a href="https://graphics.stanford.edu/papers/bssrdf/bssrdf.pdf">A Practical Model for Subsurface Light Transport</a><br>
[9] <a href="https://therealmjp.github.io/posts/sss-intro/">An Introduction To Real-Time Subsurface Scattering</a><br>
[10] <a href="http://advances.realtimerendering.com/s2018/Efficient%20screen%20space%20subsurface%20scattering%20Siggraph%202018.pdf">Efficient Screen-Space Subsurface Scattering Using Burley&rsquo;s Normalization Diffusion in Real-Time</a><br>
[11] <a href="https://agraphicsguynotes.com/posts/basics_about_path_tracing/">Basics about path tracing</a><br>
[12] <a href="http://cseweb.ucsd.edu/~viscomp/classes/cse274/wi18/readings/veach_thesis.pdf">Robust Monte Carlo Methods For Light Transport Simulation</a></p>

      </div>

      <div class="">
        <style>
    .toc {
        position: fixed;
        left: 50%;
        top: 110px;
        font-size: 0.8em;
        width: 320px;
        margin-left: 480px;
        padding-left: 20px;
        padding-bottom: 100px;
        padding-top: 80px;
        overflow-y: auto;
        line-height: 1.7em;
        scroll-padding-top: 100px;
        border-left: 3px solid rgba(128, 128, 128, 0.4);;
    }

    .toc label {
        font-size: 20px;
        font-weight: bold;
        margin: 6.4rem 0 3.2rem 0;
    }

    .toc a {
        filter: grayscale(90%);
    }

    .toc a:hover {
        font-weight: bold;
        filter: grayscale(0%);
    }

    .toc ul {
        margin-left:1px;
        padding-left: 20px;
        list-style-type: circle;
    }
    
     
    .toc ul ul{
        margin-left:1px;
        padding-left: 20px;
        list-style-type: circle;
    }

     
    .toc ul ul ul{
        margin-left:1px;
        padding-left: 20px;
        list-style-type: circle;
    }

    .toc li a.active {
        font-weight: bold;
        filter: grayscale(0%);
    }

    .toc li a.semi_active {
        font-weight: bold;
        filter: grayscale(60%);
    }

    @media (max-width: 1640px) {
      main {
        max-width: 100%;
      }
  
      .toc {
        display: none;
      }
    }

</style>
  










<div class="toc" style="display:none;">
    <label>Contents</label>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#what-is-subsurface-scattering">What is Subsurface Scattering</a></li>
    <li><a href="#basic-idea-of-sss">Basic Idea of SSS</a>
      <ul>
        <li><a href="#evaluating-bssrdf">Evaluating BSSRDF</a></li>
        <li><a href="#importance-sampling">Importance Sampling</a></li>
        <li><a href="#how-does-it-fit-in-a-path-tracing-algorithm">How Does It Fit in a Path Tracing Algorithm</a></li>
      </ul>
    </li>
    <li><a href="#enhancements">Enhancements</a>
      <ul>
        <li><a href="#reduce-fireflies">Reduce Fireflies</a>
          <ul>
            <li><a href="#dont-evaluate-sss-unnecessarily">Don&rsquo;t Evaluate SSS Unnecessarily</a>
              <ul>
                <li><a href="#what-happens-under-the-hood">What Happens Under the Hood</a></li>
                <li><a href="#the-catch-of-replacing-sss-with-lambert">The Catch of Replacing SSS with Lambert</a></li>
              </ul>
            </li>
            <li><a href="#evaluate-at-all-intersections">Evaluate at all Intersections</a></li>
          </ul>
        </li>
        <li><a href="#no-fresnel-above-sss-material">No Fresnel above SSS material</a></li>
        <li><a href="#avoid-finding-intersection-with-other-meshes">Avoid Finding Intersection with other Meshes</a></li>
        <li><a href="#refactor-material-system-in-my-renderer">Refactor Material System in my Renderer</a></li>
      </ul>
    </li>
    <li><a href="#optimizations">Optimizations</a>
      <ul>
        <li><a href="#intersection-tests">Intersection tests</a></li>
        <li><a href="#avoid-mis">Avoid MIS</a></li>
        <li><a href="#miscellaneous">Miscellaneous</a></li>
      </ul>
    </li>
    <li><a href="#a-failed-attempt">A Failed Attempt</a></li>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#referencess">Referencess</a></li>
  </ul>
</nav>
</div>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.slim.min.js" integrity="sha384-5AkRS45j4ukf+JbWAfHL8P4onPA9p0KwwP7pUdjSQA3ss9edbJUJc/XcYAiheSSz" crossorigin="anonymous"></script>
    <script>
        (function() {
            var $toc = $('#TableOfContents');
            
            if ($toc.length > 0) {
                var $window = $(window);
                
                function onScroll(){
                    var currentScroll = $window.scrollTop();
                    var h = $('h1, h2, h3, h4, h5, h6');
                    var id = "";
                    h.each(function (i, e) {
                        e = $(e);
                        if (e.offset().top - 80 <= currentScroll ) {
                            id = e.attr('id');
                        }
                    });
                    var active = $toc.find('a.active');
                    if (active.length == 1 && active.eq(0).attr('href') == '#' + id) return true;

                    active.each(function (i, e) {
                        $(e).removeClass('active').siblings('ul').hide();
                    });

                    var semi_active = $toc.find('a.semi_active');
                    semi_active.each(function (i, e) {
                        $(e).removeClass('semi_active').siblings('ul').hide();
                    });
                    
                    $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                        if( i == 0 )
                            $(e).children('a').addClass('active').siblings('ul').show();
                        else
                            $(e).children('a').addClass('semi_active').siblings('ul').show();
                    });
                }

                $window.on('scroll', onScroll);
                $(document).ready(function() {
                    $toc.find('a').parent('li').find('ul').hide();
                    onScroll();
                    document.getElementsByClassName('toc')[0].style.display = '';
                });
            }
        })();
    </script>

      </div>

      <footer>
        


        <script>
    
    function updateThemeToMatchDarkMode(isdarkmode) {
      localStorage.setItem("pref-theme", isdarkmode ? 'dark_dimmed' : 'light');

      
      const iframe = document.querySelector('iframe.giscus-frame');
      if(iframe) {
        const message = { setConfig: { theme: isdarkmode ? 'dark_dimmed' : 'light' } };
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
    }

    
    document.getElementById('dark-mode-toggle').addEventListener('click', () => {
      const isdarkmode = !document.body.classList.contains("colorscheme-dark");
      updateThemeToMatchDarkMode(isdarkmode);
    });

    
    window.onload = () => {
      const isdarkmode = document.body.classList.contains("colorscheme-dark");
      updateThemeToMatchDarkMode(isdarkmode);
    };

    
    {
      let giscusTheme = localStorage.getItem("pref-theme");
      let giscusAttributes = {
        "src": "https://giscus.app/client.js",
        "data-repo": "JiayinCao\/AGraphicsGuyNotes",
        "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMDQ5MjAzMDg=",
        "data-category": "Giscus-Comments",
        "data-category-id": "DIC_kwDOEiy29M4CTFTj",
        "data-strict" : "1",
        "data-mapping": "pathname",
        "data-reactions-enabled": "0",
        "data-emit-metadata": "0",
        "data-input-position": "bottom",
        "data-theme": giscusTheme === null ? "light" : giscusTheme,
        "data-lang": "en",
        "crossorigin": "anonymous",
        "async": "",
      };
      
      let giscusScript = document.createElement("script");
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementsByTagName("article")[0].appendChild(giscusScript);
    }
  </script>
        
        
      </footer>
    </article>

    
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
      
        Â©
        
          2015 -
        
        2025
         Jiayin Cao 
      
      
      
    </section>
  </footer>

    </main>

    
      
      <script src="/js/dark-mode.min.c2d8a1f8f2660e4a46d776277c72695a1e0ca65939d79f754441d47551604af5.js"></script>
    

    

    

    

    

    
  </body>

</html>
